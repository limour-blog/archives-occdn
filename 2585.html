

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head><!-- hexo injector head_begin start -->
  <script async src="https://analytics.umami.is/script.js" data-website-id="e59ec28a-c9a7-4104-9e62-a9f7eb3fac0b"></script>
<!-- hexo injector head_begin end -->
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://img.limour.top/2023/08/29/64ee07361815a.webp">
  <link rel="icon" href="https://img.limour.top/2023/08/29/64ee07361815a.webp">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Limour">
  <meta name="keywords" content="">
  
    <meta name="description" content="**根据转载协议，在文章的开头标明出处：深入理解语言模型的突现能力和拆解追溯 GPT-3.5 各项能力的起源转载自符尧、彭昊、Tushar Khot在notion上的文章，翻译李如寐、郭志江**。 深入理解语言模型的突现能力注：本文完成于 ChatGPT 上线之前的一个月，当时我意识到大模型非同小可，所以写下本文，希望引起更多人关注到大模型有可能带来的研究范式转变。一个月之后，ChatGPT 上线">
<meta property="og:type" content="article">
<meta property="og:title" content="【转载】深入理解语言模型的突现能力 &amp; 拆解追溯 GPT-3.5 各项能力的起源">
<meta property="og:url" content="https://occdn.limour.top/2585.html">
<meta property="og:site_name" content="Limour&#39;s Blog">
<meta property="og:description" content="**根据转载协议，在文章的开头标明出处：深入理解语言模型的突现能力和拆解追溯 GPT-3.5 各项能力的起源转载自符尧、彭昊、Tushar Khot在notion上的文章，翻译李如寐、郭志江**。 深入理解语言模型的突现能力注：本文完成于 ChatGPT 上线之前的一个月，当时我意识到大模型非同小可，所以写下本文，希望引起更多人关注到大模型有可能带来的研究范式转变。一个月之后，ChatGPT 上线">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://img.limour.top/archives_2023/2023/02/16/63edb6fe00728.webp">
<meta property="og:image" content="https://img.limour.top/archives_2023/2023/02/16/63edb8ffc6c8e.webp">
<meta property="og:image" content="https://img.limour.top/archives_2023/2023/02/16/63edba6ee6996.webp">
<meta property="og:image" content="https://img.limour.top/archives_2023/2023/02/16/63edbaab0a39f.webp">
<meta property="og:image" content="https://img.limour.top/archives_2023/2023/02/16/63edbb2bbe373.webp">
<meta property="og:image" content="https://img.limour.top/archives_2023/2023/02/16/63edbd69acfc5.webp">
<meta property="article:published_time" content="2023-02-16T05:31:26.000Z">
<meta property="article:modified_time" content="2024-03-18T11:56:18.969Z">
<meta property="article:author" content="Limour">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://img.limour.top/archives_2023/2023/02/16/63edb6fe00728.webp">
  
  
  
  <title>【转载】深入理解语言模型的突现能力 &amp; 拆解追溯 GPT-3.5 各项能力的起源 - Limour&#39;s Blog</title>

  <link  rel="stylesheet" href="https://jscdn.limour.top/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://jscdn.limour.top/npm/github-markdown-css@4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://jscdn.limour.top/npm/hint.css@2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/theme-inject/custom.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"occdn.limour.top","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"https://jscdn.limour.top/gh/Limour-dev/Sakurairo_Vision/load_svg/inload.svg","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Limour&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://img.limour.top/2023/08/29/64ee08e108638.webp') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="【转载】深入理解语言模型的突现能力 &amp; 拆解追溯 GPT-3.5 各项能力的起源"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-02-16 13:31" pubdate>
          February 16, 2023 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          19k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          156 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">【转载】深入理解语言模型的突现能力 &amp; 拆解追溯 GPT-3.5 各项能力的起源</h1>
            
            
              <div class="markdown-body">
                
                <p>**根据转载协议，在文章的开头标明出处：<a href="https://occdn.limour.top/go/#aHR0cHM6Ly95YW9mdS5ub3Rpb24uc2l0ZS81MTRmNGU2MzkxODc0OTM5OGExYThhNGM2NjBlMGQ1Yg==" rel="noopener external nofollow noreferrer">深入理解语言模型的突现能力</a>和<a href="https://occdn.limour.top/go/#aHR0cHM6Ly95YW9mdS5ub3Rpb24uc2l0ZS9HUFQtMy01LTM2MDA4MWQ5MWVjMjQ1ZjI5MDI5ZDM3YjU0NTczNzU2" rel="noopener external nofollow noreferrer">拆解追溯 GPT-3.5 各项能力的起源</a>转载自<a href="https://occdn.limour.top/go/#aHR0cHM6Ly9mcmFueHlhby5naXRodWIuaW8v" rel="noopener external nofollow noreferrer">符尧</a>、<a href="https://occdn.limour.top/go/#aHR0cHM6Ly9oYW9wZW5nLW5scC5naXRodWIuaW8v" rel="noopener external nofollow noreferrer">彭昊</a>、<a href="https://occdn.limour.top/go/#aHR0cHM6Ly9hbGxlbmFpLm9yZy90ZWFtL3R1c2hhcms=" rel="noopener external nofollow noreferrer">Tushar Khot</a>在notion上的文章，翻译<a href="https://occdn.limour.top/go/#aHR0cHM6Ly9zY2hvbGFyLmdvb2dsZS5jb20vY2l0YXRpb25zP2hsPXpoLUNOJnVzZXI9emxXQXY0Z0FBQUFK" rel="noopener external nofollow noreferrer">李如寐</a>、<a href="https://occdn.limour.top/go/#aHR0cHM6Ly9jYXJ0dXMuZ2l0aHViLmlvLw==" rel="noopener external nofollow noreferrer">郭志江</a>**。</p>
<h2 id="深入理解语言模型的突现能力"><a href="#深入理解语言模型的突现能力" class="headerlink" title="深入理解语言模型的突现能力"></a>深入理解语言模型的突现能力</h2><p>注：本文完成于 ChatGPT 上线之前的一个月，当时我意识到大模型非同小可，所以写下本文，希望引起更多人关注到大模型有可能带来的研究范式转变。一个月之后，ChatGPT 上线，全网轰动，范式从此转变。</p>
<p>最近，人们对大型语言模型所展示的强大能力（例如思维链、<a href="https://occdn.limour.top/go/#aHR0cHM6Ly9saW5nby5jc2FpbC5taXQuZWR1L2Jsb2cvYXJpdGhtZXRpY19ncHQzLw==" rel="noopener external nofollow noreferrer">便签本</a>）产生了极大的兴趣，并开展了许多工作。我们将之统称为大模型的突现能力，这些能力可能只存在于大型模型中，而不存在于较小的模型中，因此称为“突现”。其中许多能力都非常令人印象深刻，比如复杂推理、知识推理和分布外鲁棒性，我们将在后面详细讨论。值得注意的是，这些能力很接近 NLP 社区几十年来一直寻求的能力，因此代表了一种潜在的研究范式转变，即从微调小模型到使用大模型进行上下文学习。对于先行者来说，范式转变可能是很显然的。然而，出于科学的严谨性，**我们确实需要非常明确的理由来说明为什么人们应该转向大型语言模型，即使这些模型昂贵、难以使用，并且效果可能一般。**在本文中，我们将仔细研究这些能力是什么，大型语言模型可以提供什么，以及它们在更广泛的 NLP &#x2F; ML 任务中的潜在优势是什么。</p>
<p><strong>前提：</strong>我们假设读者具备以下知识：</p>
<ul>
<li>预训练、精调、提示（普通从业者应具备的自然语言处理&#x2F;深度学习能力）</li>
<li>思维链提示、便签本（普通从业者可能不太了解，但不影响阅读）</li>
</ul>
<h3 id="存在于大模型而非小模型的突现能力"><a href="#存在于大模型而非小模型的突现能力" class="headerlink" title="存在于大模型而非小模型的突现能力"></a>存在于大模型而非小模型的突现能力</h3><p><img src="https://img.limour.top/archives_2023/2023/02/16/63edb6fe00728.webp" srcset="https://jscdn.limour.top/gh/Limour-dev/Sakurairo_Vision/load_svg/inload.svg" lazyload></p>
<p>图片来自于 Wei. et. al. 2022. Chain-of-Thought Prompting Elicits Reasoning in Large Language Models。X 轴为模型大小。GSM8K是是一个小学水平的数学问题集。</p>
<p>在以上的效果图中，我们可以观察到模型的表现：</p>
<ul>
<li>当尺寸相对小的时候提升并不大</li>
<li>当模型变大时有很明显的提升</li>
</ul>
<p>这从根本上说明，某些能力可能不存在于小模型中，而是在大模型中获得的。</p>
<p>有很多种突现能力，比如 Wei 等人在 2022年 所梳理的。有些能力很有意思，但我们在本文不会讨论，比如把一串单词的最后一个字母拼起来，我们认为这是 Python 而不是语言模型要做的任务；或者3位数加法，我们认为这是计算器而不是语言模型要做的事。</p>
<p>在本文中，我们主要对以下能力感兴趣：</p>
<ul>
<li>NLP 社区近几年都关注，但之前的 NLP 模型很难达到的能力</li>
<li>源自于人类语言最深层的本质的能力（能力的深度）</li>
<li>可能达到人类智力的最高水平的能力（能力的上限）</li>
</ul>
<h4 id="突现能力的三个典型例子"><a href="#突现能力的三个典型例子" class="headerlink" title="突现能力的三个典型例子"></a>突现能力的三个典型例子</h4><p>很多有意思的能力都可以归到上文提到的类别里，在它们之中，我们主要讨论以下三种典型能力：</p>
<ul>
<li>复杂推理</li>
<li>知识推理</li>
<li>分布外鲁棒性</li>
</ul>
<p>接下来让我们一个个详细讨论。</p>
<h4 id="复杂推理"><a href="#复杂推理" class="headerlink" title="复杂推理"></a>复杂推理</h4><p>下面是一个 GSM8K 数据集中，用提示词显著超过精调的例子：</p>
<ul>
<li>问题： 克莱儿每天早饭都用 3 颗蛋做蛋卷，她 4 周会吃掉多少打鸡蛋？</li>
<li>克莱儿每天早饭都用3颗蛋做蛋卷。</li>
<li>一周有 7 天。</li>
<li>所以她一周会吃 3 * 7 &#x3D; 21 颗蛋。</li>
<li>她4周会吃掉 4 * 21 &#x3D; 84 颗蛋。</li>
<li>一打里面是 12 颗蛋。</li>
<li>所以 84 &#x2F; 12 &#x3D; 7。</li>
<li>答案是7。</li>
</ul>
<p>虽然这道题对于10岁的孩子来说很容易，但对语言模型来说却很难，主要是由于数学和语言混合在一起。</p>
<p>GSM8K 最初由 OpenAI 于 2021 年 10 月提出。当时他们用第一版GPT3在全部训练集上进行了精调，准确率约为 35%。这个结果让作者相当悲观，因为他们的结果显示了语言模型的缩放规律：随着模型大小呈指数增长，性能呈线性增长（我之后会讨论）。因此，他们在第 4.1 节中思考：</p>
<p><strong>“175B 模型似乎需要至少额外两个数量级的训练数据才能达到 80% 的求解率。”</strong></p>
<p>三个月后，即 2022 年 1 月，Wei 等人基于 540B PaLM 模型，**仅使用了 8 个思维链提示示例便将准确率提高到 56.6%**（无需将训练集增加两个数量级）。之后在 2022 年 3 月，Wang 等人基于相同的 540B PaLM 模型，通过多数投票的方法将准确率提高到 74.4%。当前的 SOTA 来自我自己在 AI2 的工作（Fu et. al. Nov 2022），我们通过使用复杂的思维链在 175B Codex 上实现了 82.9% 的准确率。从以上进展可以看到，技术进步确实呈指数级增长。</p>
<p>思维链提示是一个展示模型随着规模突现出能力的典型例子：</p>
<ul>
<li><strong>从突现能力来看</strong>：模型大小确实要大于 100B ，才能使思维链的效果大于的仅有回答提示。所以这种能力只存在于大型模型中。</li>
<li><strong>从效果来看</strong>：思想链提示的性能明显优于其之前的精调方法。</li>
<li><strong>从标注效率上来看</strong>：思维链提示只需要 8 个示例的注释，而微调需要完整的训练集。</li>
</ul>
<p>有些同学可能会认为模型能做小学数学代表不了什么（从某种意义上说，他们确实没有那么酷）。但 GSM8K 只是一个开始，最近的工作已经把前沿问题推向了高中、大学，甚至是国际数学奥林匹克问题。现在更酷了吗？</p>
<h4 id="知识推理"><a href="#知识推理" class="headerlink" title="知识推理"></a>知识推理</h4><p>下一个例子是需要知识的推理能力（例如问答和常识推理）。在这种情况下，对大型模型进行提示不一定优于精调小型模型（哪个模型更好还有待观察）。但是这个情况下的注释效率被放大了，因为：</p>
<ul>
<li>在许多数据集中，为了获得所需的背景&#x2F;常识知识，（以前很小的）模型需要一个外部语料库&#x2F;知识图谱来检索，或者需要通过多任务学习在增强的数据上进行训练</li>
<li>对于大型语言模型，可以直接去掉检索器，仅依赖模型的内部知识，且无需精调</li>
</ul>
<p><img src="https://img.limour.top/archives_2023/2023/02/16/63edb8ffc6c8e.webp" srcset="https://jscdn.limour.top/gh/Limour-dev/Sakurairo_Vision/load_svg/inload.svg" lazyload></p>
<p>图片来自于 Yu et. al. 2022. 以前的 SOTA 模型需要从外部知识源中检索。 GPT-3 的性能与以前的模型相当&#x2F;优于以前的模型，且无需检索。</p>
<p>如表中所示，与数学题的例子不同，GPT-3 并没有明显优于之前的精调模型。但它不需要从外部文档中检索，本身就包含了知识。</p>
<p>为了理解这些结果的重要性，我们可以回顾一下历史：NLP 社区从一开始就面临着<strong>如何有效编码知识</strong>的挑战。人们一直在不断探究把知识保存在模型外部或者内部的方法。上世纪九十年代以来，人们一直试图将语言和世界的规则记录到一个巨大的图书馆中，将知识存储在模型之外。但这是十分困难的，毕竟我们无法穷举所有规则。因此，研究人员开始构建特定领域的知识库，来存储非结构化文本、半结构化（如维基百科）或完全结构化（如知识图谱）等形式的知识。通常，<strong>结构化知识很难构建</strong>（因为要设计知识的结构体系），<strong>但易于推理</strong>（因为有体系结构），<strong>非结构化知识易于构建</strong>（直接存起来就行），<strong>但很难用于推理</strong>（没有体系结构）。然而，语言模型提供了一种新的方法，可以轻松地从非结构化文本中提取知识，并在不需要预定义模式的情况下有效地根据知识进行推理。下表为优缺点对比：</p>
<p><strong>构建</strong></p>
<p><strong>推理</strong></p>
<p><strong>结构化知识</strong></p>
<p>难构建<br>需要设计体系结构并解析</p>
<p>容易推理<br>有用的结构已经定义好了</p>
<p><strong>非结构化知识</strong></p>
<p>容易构建<br>只存储文本即可</p>
<p>难推理<br>需要抽取有用的结构</p>
<p><strong>语言模型</strong></p>
<p>容易构建<br>在非结构化文本上训练</p>
<p>容易推理<br>使用提示词即可</p>
<h4 id="分布外鲁棒性"><a href="#分布外鲁棒性" class="headerlink" title="分布外鲁棒性"></a>分布外鲁棒性</h4><p>我们讨论的第三种能力是分布外的鲁棒性。在 2018 年至 2022 年期间，NLP、CV 和通用机器学习领域有大量关于分布偏移&#x2F;对抗鲁棒性&#x2F;组合生成的研究，人们发现当测试集分布与训练分布不同时，模型的行为性能可能会显著下降。然而，在大型语言模型的上下文学习中似乎并非如此。Si 等人在2022年的研究显示：</p>
<p><img src="https://img.limour.top/archives_2023/2023/02/16/63edba6ee6996.webp" srcset="https://jscdn.limour.top/gh/Limour-dev/Sakurairo_Vision/load_svg/inload.svg" lazyload></p>
<p>数据来自于 Si et. al. 2022. 虽然 GPT-3 在同分布设置下比 RoBERTa 要差，但在非同分布设置下优于 RoBERTa，性能下降明显更小。</p>
<p>同样，在此实验中，同分布情况下基于提示词的 GPT-3 的效果并没有精调后的 RoBERTa要好。但它在三个其他分布（领域切换、噪声和对抗性扰动）中优于 RoBERTa，这意味着 GPT3 更加鲁棒。</p>
<p>此外，即使存在分布偏移，好的提示词所带来的泛化性能依旧会继续保持。比如：</p>
<p><img src="https://img.limour.top/archives_2023/2023/02/16/63edbaab0a39f.webp" srcset="https://jscdn.limour.top/gh/Limour-dev/Sakurairo_Vision/load_svg/inload.svg" lazyload></p>
<p>图片来自于 Fu et. al. 2022. 即使测试分布与训练分布不同，复杂提示也始终比简单提示的表现更好。</p>
<p>Fu 等人2022年的研究显示，输入提示越复杂，模型的性能就越好。这种趋势在分布转移的情况下也会继续保持：无论测试分布与原分布不同、来自于噪声分布，或者是从另一个分布转移而来的，复杂提示始终优于简单提示。</p>
<h4 id="到目前为止的总结"><a href="#到目前为止的总结" class="headerlink" title="到目前为止的总结"></a>到目前为止的总结</h4><p>在上文中，我讨论了只有大型模型才有的三种突现能力。它们是：</p>
<ul>
<li>复杂推理，大型模型在没有使用全部训练数据的情况下便显著优于以前的小型模型。</li>
<li>知识推理，大型模型可能没有小模型效果好，但大模型不需要额外的知识来源（知识可能很昂贵，或者很难从非结构化数据中抽取）。</li>
<li>分布外鲁棒性，这是之前进行模型精调时需要努力解决的问题。大型模型虽然在同分布情况下的效果不如以前的方法，但非同分布情况下的泛化性能却好得多。</li>
</ul>
<h3 id="突现能力推翻比例定律"><a href="#突现能力推翻比例定律" class="headerlink" title="突现能力推翻比例定律"></a>突现能力推翻比例定律</h3><p>鉴于上文列出的优点，大家可能会开始觉得大型语言模型确实很好了。在进一步讨论之前，让我们再回顾一下之前的工作，就会发现一个很奇怪的问题：GPT-3 在 2020 年就发布了，但为什么直到现在我们才发现并开始思考范式的转变？</p>
<p>这个问题的答案就藏在两种曲线中：对数线性曲线和相变曲线。如下图：</p>
<p><img src="https://img.limour.top/archives_2023/2023/02/16/63edbb2bbe373.webp" srcset="https://jscdn.limour.top/gh/Limour-dev/Sakurairo_Vision/load_svg/inload.svg" lazyload></p>
<p>左图: 比例定律. 当模型大小呈指数增长时，相应的模型性能呈线性增长。右图: 当模型尺寸达到一定规模时，会出现突现能力，让性能急剧增加。</p>
<p>最初，（OpenAI）的研究者认为语言模型的性能与模型尺寸的关系可以通过对数线性曲线预测，即模型尺寸呈指数增长时，性能会随之线性增加。这种现象被称为语言模型的缩放定律，正如 Kaplan 等人在2020年最初的GPT3文章中讨论的那样。重要的是，在那个阶段，即便最大的 GPT-3 在有提示的情况下也不能胜过小模型精调。所以当时并没有必要去使用昂贵的大模型（即使提示词的标注效率很高）。直到2021年，Cobbe 等人发现缩放定律同样适用于精调。这是一个有点悲观的发现，因为它意味着<strong>我们可能被锁定在模型规模上</strong>——虽然模型架构优化可能会在一定程度上提高模型性能，但效果仍会被锁定在一个区间内（对应模型规模），很难有更显著的突破。</p>
<p>在缩放定律的掌控下（2020年到2021），由于GPT-3无法胜过精调 T5-11B，同时T5-11B微调已经很麻烦了，所以NLP社区的关注点更多的是研究更小的模型或者高效参数适应。Prefix tuning就是提示和适应交叉的一个例子，后来由 He 等人在 2021统一。当时的逻辑很简单：<strong>如果精调效果更好，我们就应该在高效参数适应上多下功夫；如果提示词的方法更好，我们应该在训练大型语言模型上投入更多精力。</strong></p>
<p>之后在 2022 年 1 月，思维链的工作被放出来了。正如作者所展示的那样，思维链提示在性能-比例曲线中表现出明显的<strong>相变</strong>。当模型尺寸足够大时，性能会显著提高并明显超越比例曲线。</p>
<p>当使用思维链进行提示时，大模型在复杂推理上的表现明显优于微调，在知识推理上的表现也很有竞争力，并且分布鲁棒性也存在一定的潜力。要达到这样的效果只需要8个左右的示例，这就是为什么范式可能会转变（注：本文完成于 ChatGPT 上线之前的一个月；在 ChatGPT 上线之后，整个领域为之震撼，意识到范式已经转变了）。</p>
<h3 id="范式转变意味着什么？"><a href="#范式转变意味着什么？" class="headerlink" title="范式转变意味着什么？"></a>范式转变意味着什么？</h3><p>范式转变究竟意味着什么？下面我们给出精调和提示词方法的对比：</p>
<p>模型规模</p>
<p>小模型</p>
<p>大模型</p>
<p>学习方法</p>
<p>微调</p>
<p>上下文学习</p>
<p>学习范式</p>
<p>监督学习</p>
<p>监督学习？？</p>
<p>数据</p>
<p>完整训练数据集</p>
<p>少量上下文学习样本</p>
<p>泛化</p>
<p>分布内泛化</p>
<p>同时泛化到分布内 + 分布迁移</p>
<p>提示词的好处很明显：我们不再需要繁琐的数据标注和在全量数据上进行精调，只需要编写提示词并获得满足要求的结果，这比精调要快很多。</p>
<p>另外要注意的两点是：</p>
<p><strong>上下文学习是监督学习吗？</strong></p>
<ul>
<li>坦白讲，我不确定。</li>
<li>相似之处在于，上下文学习也需要像训练数据一样的示例</li>
<li>不同之处在于，上下文学习的泛化行为并不同于监督学习，这使得之前的泛化理论（例如 Rademancher Complexity 或 Neural Tangent Kernel）均不适用。</li>
</ul>
<p>上下文学习真的比监督学习效果要好吗？</p>
<ul>
<li>答案还未知。</li>
<li>大多数提示词和精调的对比都只比了 提示词+大模型 vs 精调+小模型，但公平的对比应该是 提示词+大模型 vs 精调+大模型，且对比时的基座模型应该一样。所以在最初的思维链文章中，如果 Wei 等人要说明提示词好于精调，他们应该对比精调后的PaLM，而不是GPT3。</li>
<li>我的假设是：<strong>精调可以提高分布内的性能，但会损害分布外的鲁棒性。提示词在分布变化的场景中表现更好，但在同分布场景下不如精调。</strong><ul>
<li>如果假设是真的，那么一个值得研究的问题就是如何在不牺牲其上下文学习能力的情况下进行精调</li>
<li><strong>注意分布外精调的效果同样会随着模型尺寸变化。</strong>比如 Yang 等人在2022年的工作中，第四张表就显示，Bart-based的分布外泛化能力会下降，但Bart-large则提升。对于大模型，当测试集的分布和训练集相差不大时，同分布的精调效果也应该会提升。</li>
</ul>
</li>
</ul>
<p>再回顾一下前文提到的的逻辑：如果精调更好，我们应该努力研究如何进行参数高效的优化；如果提示词更好，我们应该努力去训练更好的大型语言模型。</p>
<p>所以，尽管我们相信大型语言模型有巨大的潜力，仍然没有确凿的证据表明精调和提示词哪种方法更好，因此我们不确定范式是否真的应该转变、或应该转变到什么程度。仔细比较这两种范式，使我们对未来有一个清晰的认识，是非常有意义的。我们将更多讨论留到下一篇文章。</p>
<h3 id="模型应该多大才够？"><a href="#模型应该多大才够？" class="headerlink" title="模型应该多大才够？"></a>模型应该多大才够？</h3><p>两个数字：62B 和 175B。</p>
<ul>
<li>模型至少需要62B，使思维链的效果才能大于标准的提示词方法。</li>
<li>模型至少需要175B（GPT3的尺寸），思维链的效果才能大于精调小模型（T5 11B）的效果。</li>
</ul>
<p>62B这个数字来自于 Chung 等人 2022 年工作的第五张表。</p>
<p>对于所有小于62B的模型，直接用提示词都好于思维链。第一个用思维链更好的模型是 Flan-cont-PaLM 62B 在BBH上的结果。540B的模型使用思维链会在更多任务上得到好的效果，但也不是全部任务都好于精调。另外，理想的尺寸可以小于 540B，在 Suzgun 等人2022年的工作中，作者展示了175B的 InstructGPT 和 175B的 Codex 使用思维链都好于直接用提示词。综合以上结果，我们得到了63B和175B两个数字。所以，如果想要参与这场游戏，首先要有一个大于平均尺寸的模型。</p>
<p>不过，还有其他大型模型在思维链下的表现差了很多，甚至不能学到思维链，比如 OPT、BLOOM 和 GPT-3 的第一个版本。他们的尺寸都是175B。这就引出了我们下一个要讨论的问题。</p>
<h3 id="规模是唯一的因素吗？"><a href="#规模是唯一的因素吗？" class="headerlink" title="规模是唯一的因素吗？"></a>规模是唯一的因素吗？</h3><p>不是。</p>
<p>规模是一个必要但不充分的因素。有些模型足够大（比如 OPT 和 BLOOM，都是 175B），但并不能做思维链。</p>
<p>有两种模型可以做思维链:</p>
<ul>
<li>GPT3系列的模型，包括 text-davinci-002 和 code-davinci-002 (Codex)。<strong>这是仅有的两个具有强大突现能力并可公开访问的模型。</strong><ul>
<li>除了以上两个模型，其他GPT3模型，包括原来的GPT3，text-davinci-001，以及其他更小的GPT-3模型，都不能做思维链。</li>
<li>当说“能做思维链”时，我们是指使用思维链方法的效果比直接用提示词、精调T5-11B效果更好。</li>
<li>另外要注意的是，code-davinci-002 在<strong>语言</strong>任务上的性能始终优于 text-davinci-002。这个观察非常有趣且耐人寻味。这表明<strong>基于代码数据训练的语言模型可以胜过根据语言训练的语言模型。</strong>目前为止我们还不知道是为什么。</li>
</ul>
</li>
<li>PaLM系列模型，包括 PaLM、U-PaLM、Flan-PaLM 和 Minerva。这些模型目前还未开放访问（此处@谷歌，快开源吧）。</li>
</ul>
<p>为什么会有突现能力目前还不清楚，但我们找出了一下可能产生突现能力的因素：</p>
<ul>
<li>指令精调：GPT-3 text-davinci-002 就是用指令+强化学习精调的产物。在这之前，text-davinci-001 做思维链的效果并不好。同时PaLM在经过指令精调后的效果也有提升。</li>
<li>在代码上精调：Codex code-davinci-002 是在代码上进行精调的，它的效果持续好于 text-davinci-002。PaLM 也在代码上进行了调整。从表面上看，代码与语言关系不大，但似乎起了很大作用，我们会在之后的文章进行讨论。</li>
<li>用思维链精调：在 text-davinci-002 发布时，谷歌已经发布 PaLM 3 个月了。所以 OpenAI 应该看到了思维链相关的工作。还有一些工作表明，直接用思维链数据进行精调可以激发模型的思维链能力。</li>
</ul>
<p>然而，所有这些因素在现阶段都是推测。揭示如何训练才能让模型产生突现能力是非常有意义的，我们将更多讨论留到下一篇文章。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本文中，我们仔细研究了语言模型的突现能力。我们强调了复杂推理、知识推理和分布外鲁棒性的重要性和其中存在的机会。突现能力是非常令人兴奋的，因为它们可以超越比例定律，并在比例曲线中表现出相变。我们详细讨论了研究范式是否会真的从精调转向上下文学习，但我们目前还没有确切答案，因为精调和上下文学习在分布内、分布外场景下的效果仍有待对比。最后，我们讨论了产生突现能力的三个潜在因素：指令精调、代码精调和思维链精调。非常欢迎大家提出建议和讨论。</p>
<p>另外我们还提到了两个尚未讨论的有趣问题：</p>
<ul>
<li>我们是否能公平对比精调和上下文学习的效果？</li>
<li>我们是如何训练大模型，才能让模型具备突现能力、思维链能力？</li>
</ul>
<p>对于这两个问题，我们会在之后的文章中进行讨论。</p>
<h2 id="拆解追溯-GPT-3-5-各项能力的起源"><a href="#拆解追溯-GPT-3-5-各项能力的起源" class="headerlink" title="拆解追溯 GPT-3.5 各项能力的起源"></a>拆解追溯 GPT-3.5 各项能力的起源</h2><p>最近，OpenAI的预训练模型ChatGPT给人工智能领域的研究人员留下了深刻的印象和启发。毫无疑问，它又强又聪明，且跟它说话很好玩，还会写代码。它在多个方面的能力远远超过了自然语言处理研究者们的预期。于是我们自然就有一个问题：ChatGPT 是怎么变得这么强的？它的各种强大的能力到底从何而来？在这篇文章中，我们试图剖析 ChatGPT 的突现能力（Emergent Ability），追溯这些能力的来源，希望能够给出一个全面的技术路线图，来说明 GPT-3.5 模型系列以及相关的大型语言模型是如何一步步进化成目前的强大形态。</p>
<p>我们希望这篇文章能够促进大型语言模型的透明度，成为开源社区共同努力复现 GPT-3.5 的路线图。</p>
<p>“多年以后，面对行刑队，奥雷里亚诺·布恩迪亚上校将会回想起父亲带他去见识冰块的那个遥远的下午”</p>
<p>—— <em>《百年孤独》</em> 加西亚·马尔克斯</p>
<h3 id="一、2020-版初代-GPT-3-与大规模预训练"><a href="#一、2020-版初代-GPT-3-与大规模预训练" class="headerlink" title="一、2020 版初代 GPT-3 与大规模预训练"></a>一、2020 版初代 GPT-3 与大规模预训练</h3><p>初代GPT-3展示了三个重要能力：</p>
<ul>
<li><strong>语言生成</strong>：遵循提示词（prompt），然后生成补全提示词的句子 (completion)。这也是今天人类与语言模型最普遍的交互方式。</li>
<li><strong>上下文学习 (in-context learning)</strong>: 遵循给定任务的几个示例，然后为新的测试用例生成解决方案。很重要的一点是，GPT-3虽然是个语言模型，但它的论文几乎没有谈到“语言建模” (language modeling) —— 作者将他们全部的写作精力都投入到了对上下文学习的愿景上，这才是 GPT-3的真正重点。</li>
<li>**世界知识 (world knowledge)**：包括事实性知识 (factual knowledge) 和常识 (commonsense)。</li>
</ul>
<p>那么这些能力从何而来呢？</p>
<p>基本上，以上三种能力都来自于大规模预训练：在有3000亿单词的语料上预训练拥有1750亿参数的模型（ 训练语料的60%来自于 2016 - 2019 的 C4 + 22% 来自于 WebText2 + 16% 来自于Books + 3%来自于Wikipedia）。其中：</p>
<ul>
<li><strong>语言生成</strong>的能力来自于语言建模的<strong>训练目标</strong> (language modeling)。</li>
<li><strong>世界知识</strong>来自 3000 亿单词的<strong>训练语料库</strong>（不然还能是哪儿呢）。</li>
<li><strong>模型的 1750 亿参数</strong>是为了<strong>存储知识</strong>，Liang et al. (2022) 的文章进一步证明了这一点。 他们的结论是，知识密集型任务的性能与模型大小息息相关。</li>
<li>上下文学习的能力来源及为什么上下文学习可以泛化，**仍然难以溯源。**直觉上，这种能力可能来自于同一个任务的数据点在训练时按顺序排列在同一个 batch 中。然而，很少有人研究为什么语言模型预训练会促使上下文学习，以及为什么上下文学习的行为与微调 (fine-tuning) 如此不同。</li>
</ul>
<p>令人好奇的是，初代的<strong>GPT-3有多强。</strong> 其实比较难确定初代 GPT-3（在 OpenAI API 中被称为<code>davinci</code>）到底是“强”还是“弱”。一方面，它合理地回应了某些特定的查询，并在许多数据集中达到了还不错的性能；另一方面，它在许多任务上的<strong>表现还不如 T5 这样的小模型</strong>（参见其原始论文）。在今天（2022 年 12 月）ChatGPT 的标准下，很难说初代的 GPT-3 是“智能的”。Meta 开源的 OPT 模型试图复现初代 GPT-3，但它的能力与当今的标准也形成了尖锐的对比。许多测试过 OPT 的人也认为与现在的<code>text-davinci-002</code>相比，该模型确实 “不咋地”。尽管如此，OPT 可能是初代 GPT-3 的一个足够好的开源的近似模型了（根据 OPT 论文和斯坦福大学的 HELM 评估）。</p>
<p>虽然初代的 GPT-3 可能表面上看起来很弱，但后来的实验证明，初代 GPT-3 有着非常强的潜力。这些潜力后来被代码训练、指令微调 (instruction tuning) 和基于人类反馈的强化学习 (reinforcement learning with human feedback, RLHF) 解锁，最终体展示出极为强大的突现能力。</p>
<h3 id="二、从-2020-版-GPT-3-到-2022-版-ChatGPT"><a href="#二、从-2020-版-GPT-3-到-2022-版-ChatGPT" class="headerlink" title="二、从 2020 版 GPT-3 到 2022 版 ChatGPT"></a>二、从 2020 版 GPT-3 到 2022 版 ChatGPT</h3><p>从最初的 GPT-3 开始，为了展示 OpenAI 是如何发展到ChatGPT的，我们看一下 GPT-3.5 的进化树：</p>
<p><img src="https://img.limour.top/archives_2023/2023/02/16/63edbd69acfc5.webp" srcset="https://jscdn.limour.top/gh/Limour-dev/Sakurairo_Vision/load_svg/inload.svg" lazyload></p>
<p>在 <strong>2020 年 7 月</strong>，OpenAI 发布了模型索引为的 <code>davinci</code> 的初代 GPT-3 论文，从此它就开始不断进化。在 <strong>2021 年 7 月</strong>，Codex 的论文发布，其中初始的 Codex 是根据（可能是内部的）120 亿参数的 GPT-3 变体进行微调的。后来这个 120 亿参数的模型演变成 OpenAI API 中的<code>code-cushman-001</code>。在 <strong>2022 年 3 月</strong>，OpenAI 发布了指令微调 (instruction tuning) 的论文，其监督微调 (supervised instruction tuning) 的部分对应了<code>davinci-instruct-beta</code>和<code>text-davinci-001</code>。在 <strong>2022 年 4 月至 7 月的</strong>，OpenAI 开始对<code>code-davinci-002</code>模型进行 Beta 测试，也称其为 Codex。然后<code>code-davinci-002</code>、<code>text-davinci-003</code>和<code>ChatGPT</code> 都是从<code>code-davinci-002</code>进行指令微调得到的。详细信息请参阅 OpenAI的模型索引文档。</p>
<p>尽管 Codex 听着像是一个只管代码的模型，但<code>code-davinci-002</code>可能是最强大的针对<strong>自然语言</strong>的GPT-3.5 变体（优于 <code>text-davinci-002</code>和 <code>-003</code>）。<code>code-davinci-002</code>很可能在文本和代码上都经过训练，然后根据指令进行调整（将在下面解释）。然后<strong>2022 年 5-6 月</strong>发布的<code>text-davinci-002</code>是一个基于<code>code-davinci-002</code>的有监督指令微调 (supervised instruction tuned) 模型。在<code>text-davinci-002</code>上面进行<strong>指令微调</strong>很可能<strong>降低</strong>了模型的<strong>上下文学习</strong>能力**，<strong>但是</strong>增强了<strong>模型的</strong>零样本能力**（将在下面解释）。然后是<code>text-davinci-003</code>和 <code>ChatGPT</code>，它们都在 <strong>2022 年 11 月</strong>发布，是使用的基于人类反馈的强化学习的版本指令微调 (instruction tuning with reinforcement learning from human feedback) 模型的两种不同变体。<code>text-davinci-003</code> 恢复了（但仍然比<code>code-davinci-002</code>差）一些在<code>text-davinci-002</code> 中丢失的部分<strong>上下文学习能</strong>力（大概是因为它在微调的时候混入了语言建模） 并进一步改进了零样本能力（得益于RLHF）。另一方面，ChatGPT 似乎<strong>牺牲了几乎所有的上下文学习的能力</strong>来<strong>换取</strong>建模对话历史的能力。</p>
<p>总的来说，在 2020 - 2021 年期间，在<code>code-davinci-002</code>之前，OpenAI 已经投入了大量的精力通过代码训练和指令微调来增强GPT-3。当他们完成<code>code-davinci-002</code>时，所有的能力都已经存在了。很可能后续的指令微调，无论是通过有监督的版本还是强化学习的版本，都会做以下事情（稍后会详细说明）：</p>
<ul>
<li>指令微调<strong>不会为模型注入新的能力</strong> —— 所有的能力都已经存在了。指令微调的作用是<strong>解锁 &#x2F; 激发这些能力</strong>。这主要是因为指令微调的数据量比预训练数据量少几个数量级（基础的能力是通过预训练注入的）。</li>
<li>指令微调**将 GPT-3.5 的分化到不同的技能树。**有些更擅长上下文学习，如<code>text-davinci-003</code>，有些更擅长对话，如<code>ChatGPT</code>。</li>
<li>指令微调<strong>通过牺牲性能换取与人类的对齐（alignment）</strong>。 OpenAI 的作者在他们的指令微调论文中称其为 “对齐税” (alignment tax)。许多论文都报道了<code>code-davinci-002</code>在基准测试中实现了最佳性能（但模型不一定符合人类期望）。 在<code>code-davinci-002</code>上进行指令微调后，模型可以生成更加符合人类期待的反馈（或者说模型与人类对齐），例如：零样本问答、生成安全和公正的对话回复、拒绝超出模型它知识范围的问题。</li>
</ul>
<h3 id="三、Code-Davinci-002和-Text-Davinci-002，在代码上训练，在指令上微调"><a href="#三、Code-Davinci-002和-Text-Davinci-002，在代码上训练，在指令上微调" class="headerlink" title="三、Code-Davinci-002和 Text-Davinci-002，在代码上训练，在指令上微调"></a>三、Code-Davinci-002和 Text-Davinci-002，在代码上训练，在指令上微调</h3><p>在code-davinci-002和text-davinci-002之前，有两个中间模型，分别是 davinci-instruct-beta 和 text-davinci-001。两者在很多方面都比上述的两个-002模型差（例如，text-davinci-001 链式思维推理能力不强）。所以我们在本节中重点介绍 -002 型号。</p>
<h4 id="3-1-复杂推理能力的来源和泛化到新任务的能力"><a href="#3-1-复杂推理能力的来源和泛化到新任务的能力" class="headerlink" title="3.1 复杂推理能力的来源和泛化到新任务的能力"></a>3.1 复杂推理能力的来源和泛化到新任务的能力</h4><p>我们关注<code>code-davinci-002</code>和<code>text-davinci-002</code>，这两兄弟是第一版的 GPT3.5 模型，一个用于代码，另一个用于文本。它们表现出了四种与初代 GPT-3 不同的重要能力：</p>
<ul>
<li><strong>响应人类指令</strong>：以前，GPT-3 的输出主要训练集中常见的句子。现在的模型会针对指令 &#x2F; 提示词生成更合理的答案（而不是相关但无用的句子）。</li>
<li><strong>泛化到没有见过的任务</strong>：当用于调整模型的指令数量超过一定的规模时，模型就可以自动在从没见过的新指令上也能生成有效的回答。 <strong>这种能力对于上线部署至关重要</strong>，因为用户总会提新的问题，模型得答得出来才行。</li>
<li><strong>代码生成和代码理解</strong>：这个能力很显然，因为模型用代码训练过。</li>
<li><strong>利用思维链 (chain-of-thought) 进行复杂推理</strong>：初代 GPT3 的模型思维链推理的能力很弱甚至没有。 <strong>code-davinci-002 和 text-davinci-002 是两个拥有足够强的思维链推理能力的模型。</strong><ul>
<li>思维链推理之所以重要，是因为思维链可能是解锁突现能力和超越缩放法则 (scaling laws) 的关键。请参阅上一篇博文。</li>
</ul>
</li>
</ul>
<p>这些能力从何而来？</p>
<p>与之前的模型相比，两个主要区别是<strong>指令微调</strong>和<strong>代码训练</strong>。具体来说</p>
<ul>
<li>能够<strong>响应人类指令</strong>的能力是<strong>指令微调</strong>的直接产物。</li>
<li><strong>对没有见过的指令做出反馈</strong>的泛化能力是在指令数量超过一定程度之后<strong>自动出现的</strong>，T0、Flan 和 FlanPaLM 论文进一步证明了这一点</li>
<li>使用<strong>思维链</strong>进行<strong>复杂推理</strong>的能力很可能是<strong>代码训练</strong>的<strong>一个神奇的副产物</strong>。对此，我们有以下的事实作为一些支持：<ul>
<li>最初的 GPT-3 没有接受过代码训练，它不能做<strong>思维链</strong>。</li>
<li>text-davinci-001 模型，虽然经过了指令微调，但第一版思维链论文报告说，它的它思维链推理的能力非常弱 —— <strong>所以指令微调可能不是思维链存在的原因，代码训练才是模型能做思维链推理的最可能原因。</strong></li>
<li>PaLM 有 5% 的代码训练数据，可以做思维链。</li>
<li>Codex论文中的代码数据量为 159G ，大约是初代 GPT-3 5700 亿训练数据的28%。code-davinci-002 及其后续变体可以做思维链推理。</li>
<li>在 HELM 测试中，Liang et al. (2022) 对不同模型进行了大规模评估。 他们发现了针对代码训练的模型具有很强的语言推理能力，包括 120亿参数的code-cushman-001.。</li>
<li>我们在 AI2 的工作也表明，当配备复杂的思维链时，code-davinci-002 在 GSM8K 等重要数学基准上是目前表现最好的模型</li>
<li>直觉来说，<strong>面向过程的编程 (procedure-oriented programming)</strong> 跟人类<strong>逐步解决任务</strong>的过程很类似，<strong>面向对象编程 (object-oriented programming)</strong> 跟人类<strong>将复杂任务分解为多个简单任务</strong>的过程很类似。</li>
<li>以上所有观察结果都是代码与推理能力 &#x2F; 思维链 之间的相关性，但不一定是因果性。这种相关性很有趣，但现在还是一个待研究的开放性问题。目前看来，我们<strong>没有非常确凿的证据证明代码就是思维链和复杂推理的原因</strong>。</li>
</ul>
</li>
<li>此外， <strong>代码训练</strong>另一个可能的副产品是**长距离依赖，**正如Peter Liu所指出：“语言中的下个词语预测通常是非常局部的，而代码通常需要更长的依赖关系来做一些事情，比如前后括号的匹配或引用远处的函数定义”。这里我想进一步补充的是：由于面向对象编程中的类继承，代码也可能有助于模型建立编码层次结构的能力。我们将对这一假设的检验留给未来的工作。</li>
</ul>
<p>另外还要注意一些细节差异：</p>
<ul>
<li><strong>text-davinci-002 与 code-davinci-002</strong><ul>
<li>Code-davinci-002 是基础模型，text-davinci-002 是指令微调 code-davinci-002 的产物（见 OpenAI 的文档）。它在以下数据上作了微调：（一）人工标注的指令和期待的输出；（二）由人工标注者选择的模型输出。</li>
<li>当有上下文示例 (in-context example) 的时候， Code-davinci-002 更擅长上下文学习；当没有上下文示例 &#x2F; 零样本的时候， text-davinci-002 在零样本任务完成方面表现更好。从这个意义上说，text-davinci-002 更符合人类的期待（因为对一个任务写上下文示例可能会比较麻烦）。</li>
<li>OpenAI 不太可能故意牺牲了上下文学习的能力换取零样本能力 —— 上下文学习能力的降低更多是指令学习的一个副作用，OpenAI 管这叫对齐税。</li>
</ul>
</li>
<li><strong>001 模型（code-cushman-001 和 text-davinci-001）v.s. 002 模型（code-davinci-002 和 text-davinci-002）</strong><ul>
<li>001 模型主要是为了做纯代码 &#x2F; 纯文本任务； 002 模型则深度融合了代码训练和指令微调，代码和文本都行。</li>
<li>Code-davinci-002 可能是第一个深度融合了代码训练和指令微调的模型。证据有：code-cushman-001 可以进行推理但在纯文本上表现不佳，text-davinci-001 在纯文本上表现不错但在推理上不大行。 code-davinci-002 则可以同时做到这两点。</li>
</ul>
</li>
</ul>
<h4 id="3-2-这些能力是在预训练之后已经存在还是在之后通过微调注入？"><a href="#3-2-这些能力是在预训练之后已经存在还是在之后通过微调注入？" class="headerlink" title="3.2 这些能力是在预训练之后已经存在还是在之后通过微调注入？"></a>3.2 这些能力是在预训练之后已经存在还是在之后通过微调注入？</h4><p>在这个阶段，我们已经确定了指令微调和代码训练的关键作用。一个重要的问题是如何进一步分析代码训练和指令微调的影响？具体来说： 上述三种能力是否<strong>已经存在于初代的GPT-3</strong>中，只是<strong>通过指令和代码训练触发 &#x2F; 解锁</strong>？ 或者这些能力在初代的 GPT-3 中<strong>并不存在</strong>，是通过指令和代码训练<strong>注入？</strong> 如果答案已经在初代的 GPT-3 中，<strong>那么这些能力也应该在 OPT 中。 因此，要复现这些能力，或许可以直接通过指令和代码调整 OPT。</strong> 但是，code-davinci-002 也可能不是基于最初的 GPT-3 davinci，而是基于比初代 GPT-3 更大的模型。如果是这种情况，可能就没办法通过调整 OPT 来复现了。研究社区需要进一步弄清楚 OpenAI 训练了什么样的模型作为 code-davinci-002 的基础模型。</p>
<p>我们有以下的假设和证据：</p>
<ul>
<li>code-davinci-002的<strong>基础模型可能不是初代GPT-3 davinci 模型</strong>。以下是证据：<ul>
<li>初代的GPT-3在数据集 C4 2016 - 2019 上训练，而 code-davinci-002 训练集则在延长到2021年才结束。因此 code-davinci-002 有可能在 C4 的 2019-2021 版本上训练。</li>
<li>初代的 GPT-3 有一个大小为 <strong>2048</strong> 个词的上下文窗口。code-davinci-002 的上下文窗口则为 <strong>8192</strong>。GPT 系列使用绝对位置嵌入 (absolute positional embedding)，直接对绝对位置嵌入进行外推而不经过训练是比较难的，并且会严重损害模型的性能（参考 Press et al., 2022）。如果 code-davinci-002 是基于初代GPT-3，那OpenAI 是如何扩展上下文窗口的？</li>
</ul>
</li>
<li>另一方面，无论基础模型是初代的 GPT-3 还是后来训练的模型， <strong>遵循指令和零样本泛化的能力都可能已经存在于基础模型</strong>中，后来才通过指令微调来<strong>解锁</strong> （<strong>而不是注入）</strong><ul>
<li>这主要是因为 OpenAI 的论文报告的指令数据量大小只有 77K，比预训练数据少了几个数量级。</li>
<li>其他指令微调论文进一步证明了数据集大小对模型性能的对比，例如 Chung et al. (2022) 的工作中， Flan-PaLM 的指令微调仅为预训练计算的 0.4%。一般来说，指令数据会显著少于预训练数据。</li>
</ul>
</li>
<li>然而 <strong>，模型的复杂推理能力可能是在预训练阶段通过代码数据注入</strong><ul>
<li>代码数据集的规模与上述指令微调的情况不同。这里的代码数据量足够大，可以占据训练数据的重要部分（例如，PaLM 有 8% 的代码训练数据）</li>
<li>如上所述，在 code-davinci-002 之前的模型 text-davinci-001 大概没有在代码数据上面微调过，所以它的推理 &#x2F; 思维链能力是非常差的，正如第一版思维链论文中所报告的那样，有时甚至比参数量更小的 code-cushman-001 还差。</li>
</ul>
</li>
<li><strong>区分代码训练和指令微调效果的最好方法</strong>可能是<strong>比较 code-cushman-001、T5 和 FlanT5</strong><ul>
<li>因为它们具有相似的模型大小（110亿 和 120亿），相似的训练数据集 (C4)，它们最大的区别就是有没有在代码上训练过 &#x2F; 有没有做过指令微调。</li>
<li>目前还没有这样的比较。我们把这个留给未来的研究。</li>
</ul>
</li>
</ul>
<h3 id="四、text-davinci-003-和-ChatGPT，基于人类反馈的强化学习-Reinforcement-Learning-from-Human-Feedback-RLHF-的威力"><a href="#四、text-davinci-003-和-ChatGPT，基于人类反馈的强化学习-Reinforcement-Learning-from-Human-Feedback-RLHF-的威力" class="headerlink" title="四、text-davinci-003 和 ChatGPT，基于人类反馈的强化学习(Reinforcement Learning from Human Feedback, RLHF) 的威力"></a>四、text-davinci-003 和 ChatGPT，基于人类反馈的强化学习(Reinforcement Learning from Human Feedback, RLHF) 的威力</h3><p>在当前阶段（2022 年 12 月）， text-davinci-002、text-davinci-003 和 ChatGPT之间<strong>几乎没有严格的统计上的比较</strong> ，主要是因为</p>
<ul>
<li>text-davinci-003 和 ChatGPT 在撰写本文时才发布不到一个月。</li>
<li>ChatGPT 不能通过 OpenAI API 被调用，所以想要在标准基准上测试它很麻烦。</li>
</ul>
<p>所以在这些模型之间的比较更多是<strong>基于研究社区的集体经验</strong> （统计上不是很严格）。不过，我们相信初步的描述性比较仍然可以揭示模型的机制。</p>
<p>我们首先注意到以下 text-davinci-002，text-davinci-003 和 ChatGPT 之间的比较：</p>
<ul>
<li>所有三个模型都经过<strong>指令微调</strong>。</li>
<li><strong>text-davinci-002</strong> 是一个经过<strong>监督学习指令微调</strong> (supervised instruction tuning) ****的模型</li>
<li><strong>text-davinci-003 和 ChatGPT</strong> 是<strong>基于人类反馈的强化学习的指令微调</strong> (Instruction tuning with Reinforcement Learning from Human Feedback, RLHF)。这是它们之间最显着的区别。</li>
</ul>
<p><strong>这意味着大多数新模型的行为都是 RLHF 的产物</strong>。</p>
<p>那么让我们看看 RLHF 触发的能力：</p>
<ul>
<li><strong>翔实的回应：</strong> text-davinci-003 的生成通常比 text-davinci-002长。 ChatGPT 的回应则更加冗长，以至于用户必须明确要求“用一句话回答我”，才能得到更加简洁的回答。这是 RLHF 的直接产物。</li>
<li><strong>公正的回应：</strong>ChatGPT 通常对涉及多个实体利益的事件（例如政治事件）给出非常平衡的回答。这也是RLHF的产物。</li>
<li><strong>拒绝不当问题：</strong>这是内容过滤器和由 RLHF 触发的模型自身能力的结合，过滤器过滤掉一部分，然后模型再拒绝一部分。</li>
<li><strong>拒绝其知识范围之外的问题：</strong>例如，拒绝在2021 年 6 月之后发生的新事件（因为它没在这之后的数据上训练过）。这是 RLHF 最神奇的部分，因为它使模型能够隐式地区分哪些问题在其知识范围内，哪些问题不在其知识范围内。</li>
</ul>
<p>有两件事情值得注意：</p>
<ul>
<li>所有的能力都是模型本来就有的， <strong>而不是通过RLHF 注入的</strong>。 RLHF 的作用是<strong>触发 &#x2F; 解锁突现能力</strong>。这个论点主要来自于数据量大小的比较：因为与预训练的数据量相比，RLHF 占用的计算量 &#x2F; 数据量要少得多。</li>
<li>模型<strong>知道它不知道什么不是通过编写规则来实现的，</strong> 而是通过RLHF解锁的。这是一个非常令人惊讶的发现，因为 RLHF 的最初目标是让模型生成符合人类期望的回答，这更多是让模型生成安全的句子，而不是让模型知道它不知道的内容。</li>
</ul>
<p>幕后发生的事情可能是：</p>
<ul>
<li>ChatGPT: 通过<strong>牺牲上下文学习</strong>的能力<strong>换取建模对话历史</strong>的能力。这是一个基于经验的观测结果，因为 ChatGPT 似乎不像 text-davinci-003 那样受到上下文演示的强烈影响。</li>
<li>text-davinci-003：<strong>恢复了</strong> text-davinci-002 所牺牲的<strong>上下文学习能力</strong>， <strong>提高零样本的能力</strong>。 我们不确定这是否也是 RLHF 或其他东西的副产品。 根据instructGPT的论文，这是来自于强化学习调整阶段混入了语言建模的目标（而不是 RLHF 本身）。</li>
</ul>
<h3 id="五、总结当前阶段-GPT-3-5-的进化历程"><a href="#五、总结当前阶段-GPT-3-5-的进化历程" class="headerlink" title="五、总结当前阶段 GPT-3.5 的进化历程"></a>五、总结当前阶段 GPT-3.5 的进化历程</h3><p>到目前为止，我们已经仔细检查了沿着进化树出现的所有能力，下表总结了演化路径：</p>
<p>能力</p>
<p>OpenAI模型</p>
<p>训练方法</p>
<p>OpenAI API</p>
<p>OpenAI论文</p>
<p>近似的开源模型</p>
<p>GPT-3系列</p>
<p>语言生成 + 世界知识 + 上下文学习</p>
<p>GPT-3初始版本 **大部分的能力已经存在于模型中，尽管表面上看起来很弱。</p>
<p>语言建模</p>
<p>Davinci</p>
<p>GPT-3论文</p>
<p>Meta OPT</p>
<p>+ 遵循人类的指令 + 泛化到没有见过的任务</p>
<p>Instruct-GPT初始版本</p>
<p>指令微调</p>
<p>Davinci-Instruct-Beta</p>
<p>Instruct-GPT论文</p>
<p>T0论文Google FLAN论文</p>
<p>+ 代码理解 + 代码生成</p>
<p>Codex初始版本</p>
<p>在代码上进行训练</p>
<p>Code-Cushman-001</p>
<p>Codex论文</p>
<p>Salesforce CodeGen</p>
<p>GPT-3.5系列</p>
<p>++ 代码理解 ++ 代码生成 ++ 复杂推理 &#x2F; 思维链 (为什么?) + 长距离的依赖 (很可能)</p>
<p>现在的Codex **GPT3.5系列中最强大的模型</p>
<p>在代码+文本上进行训练 在指令上进行微调</p>
<p>Code-Davinci-002 (目前免费的版本 &#x3D; 2022年12月)</p>
<p>Codex 论文</p>
<p>++ 遵循人类指令 - 上下文学习 - 推理能力 ++ 零样本生成</p>
<p>有监督的Instruct-GPT **通过牺牲上下文学习换取零样本生成的能力</p>
<p>监督学习版的指令微调</p>
<p>Text-Davinci-002</p>
<p>Instruct-GPT论文, 有监督的部分</p>
<p>T0论文 Google FLAN论文</p>
<p>+ 遵循人类价值观 + 包含更多细节的生成 + 上下文学习 + 零样本生成</p>
<p>经过RLHF训练的Instruct-GPT **和002模型相比，和人类更加对齐，并且更少的性能损失</p>
<p>强化学习版的指令微调</p>
<p>Text-Davinci-003</p>
<p>Instruct-GPT论文, RLHF部分，从人类反馈中的学习摘要。</p>
<p>DeepMind Sparrow 论文AI2 RL4LMs</p>
<p>++ 遵循人类价值观 ++ 包含更多细节的生成 ++ 拒绝知识范围外的问题 (为什么?) ++ 建模对话历史的能力 – 上下文学习</p>
<p>ChatGPT ** 通过牺牲上下文学习的能力换取建模对话历史的能力</p>
<p>使用对话数据进行强化学习指令微调</p>
<p>DeepMind Sparrow论文 AI2 RL4LMs</p>
<p>我们可以得出结论：</p>
<ul>
<li>语言生成能力 + 基础世界知识 + 上下文学习都是来自于预训练（<code>davinci</code>）</li>
<li>存储大量知识的能力来自 1750 亿的参数量。</li>
<li>遵循指令和泛化到新任务的能力来自于扩大指令学习中指令的数量（<code>Davinci-instruct-beta</code>)</li>
<li>执行复杂推理的能力很可能来自于代码训练（<code>code-davinci-002</code>）</li>
<li>生成中立、客观的能力、安全和翔实的答案来自与人类的对齐。具体来说：<ul>
<li>如果是监督学习版，得到的模型是<code>text-davinci-002</code></li>
<li>如果是强化学习版 (RLHF) ，得到的模型是<code>text-davinci-003</code></li>
<li>无论是有监督还是 RLHF ，模型在很多任务的性能都无法超过 code-davinci-002 ，这种因为对齐而造成性能衰退的现象叫做对齐税。</li>
</ul>
</li>
<li>对话能力也来自于 RLHF（<code>ChatGPT</code>），具体来说它牺牲了上下文学习的能力，来换取：<ul>
<li>建模对话历史</li>
<li>增加对话信息量</li>
<li>拒绝模型知识范围之外的问题</li>
</ul>
</li>
</ul>
<h3 id="六、GPT-3-5-目前不能做什么"><a href="#六、GPT-3-5-目前不能做什么" class="headerlink" title="六、GPT-3.5 目前不能做什么"></a>六、GPT-3.5 目前不能做什么</h3><p>虽然GPT-3.5是自然语言处理研究中的重要一步，但它并没有完全包含许多研究人员（包括 AI2）设想的所有理想属性。以下是GPT-3.5不具备的某些重要属性：</p>
<ul>
<li><strong>实时改写模型的信念</strong>：当模型表达对某事的信念时，如果该信念是错误的，我们可能很难纠正它：<ul>
<li>我最近遇到的一个例子是：ChatGPT 坚持认为 3599 是一个质数，尽管它承认 3599 &#x3D; 59 * 61。另外，请参阅Reddit上关于游得最快的海洋哺乳动物的例子。</li>
<li>然而，模型信念的强度似乎存在不同的层次。一个例子是即使我告诉它达斯·维达（星球大战电影中的人物）赢得了2020年大选，模型依旧会认为美国现任总统是拜登。但是如果我将选举年份改为 2024 年，它就会认为总统是达斯·维达是 2026 年的总统。</li>
</ul>
</li>
<li><strong>形式推理</strong>：GPT-3.5系列不能在数学或一阶逻辑等形式严格的系统中进行推理：<ul>
<li>在自然语言处理的文献中， “推理” 一词的定义很多时候不太明确。但如果我们从模糊性的角度来看，例如一些问题 (a) 非常模棱两可，没有推理；(b) 有点儿逻辑在里面，但有些地方也可以模糊；(c) 非常严谨，不能有任何歧义。那么，</li>
<li>模型可以很好地进行 (b) 类的带模糊性的推理，例子有：<ul>
<li>生成如何做豆腐脑的方法。做豆腐脑的时候，中间很多步骤模糊一点是可以接受的，比如到底是做咸的还是做甜的。只要整体步骤大致正确，做出来的豆腐脑儿就能吃。</li>
<li>数学定理的证明思路。证明思路是用语言表达的非正式的逐步解法，其中每一步的严格推导可以不用太具体。证明思路经常被用到数学教学：只要老师给一个大致正确的整体步骤，学生就可以大概明白。然后老师把具体的证明细节作为作业布置给学生，答案略。</li>
</ul>
</li>
<li>GPT-3.5 不能进行类型 (c) 的推理（推理不能容忍歧义）。<ul>
<li>一个例子是严格的数学证明，要求中间步骤中不能跳，不能模糊，不能错。</li>
<li>但这种严格推理到底是应该让语言模型做还是让符号系统做还有待讨论。一个例子是，与其努力让 GPT 做三位数加法，不如直接调 Python。</li>
</ul>
</li>
</ul>
</li>
<li><strong>从互联网进行检索</strong>：GPT-3.5 系列（暂时）不能直接搜索互联网<ul>
<li>但是有一篇 WebGPT 论文发表于2021年12月，里面就让 GPT 调用了搜索引擎。所以检索的能力已经在 OpenAI 内部进行了测试。</li>
<li>这里需要区分的一点是，GPT-3.5 的两个重要但不同的能力是 <strong>知识</strong> 和 <strong>推理</strong>。一般来说，如果我们能够 <strong>将知识部分卸载到外部的检索系统，让语言模型只专注于推理，这就很不错了。</strong> 因为：<ul>
<li>模型的内部知识总是在某个时间被切断。模型始终需要最新的知识来回答最新的问题。</li>
<li>回想一下，我们已经讨论过 1750 亿的参数大量用于存储知识。如果我们可以将知识卸载到模型之外，那么模型参数可能会大大减少，最终它甚至可以在手机上运行（疯狂的想法，但 ChatGPT 已经足够科幻了，谁知道未来会怎样呢).</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="七、结论"><a href="#七、结论" class="headerlink" title="七、结论"></a>七、结论</h3><p>在这篇博文中，我们仔细检查了GPT-3.5系列的能力范围，并追溯了它们所有突现能力的来源。初代GPT-3模型通过预训练获得生成能力、世界知识和in-context learning。然后通过instruction tuning的模型分支获得了遵循指令和能泛化到没有见过的任务的能力。经过代码训练的分支模型则获得了代码理解的能力，作为代码训练的副产品，模型同时潜在地获得了复杂推理的能力。结合这两个分支，code-davinci-002似乎是具有所有强大能力的最强GPT-3.5模型。接下来通过有监督的instruction tuning和 RLHF通过牺牲模型能力换取与人类对齐，即对齐税。 RLHF 使模型能够生成更翔实和公正的答案，同时拒绝其知识范围之外的问题。</p>
<p>我们希望这篇文章能够帮助提供一个清晰的GPT评估图，并引发一些关于语言模型、instruction tuning和code tuning的讨论。最重要的是， <strong>我们希望这篇文章可以作为在开源社区内复现GPT-3.5的路线图。</strong></p>
<p>“因为山就在那里。”</p>
<p>——乔治·马洛里，珠穆朗玛峰探险先驱</p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul>
<li>这篇文章中的这些说法更像是假设 (hypothesis) 还是结论 (conclusion)？<ul>
<li><strong>复杂推理的能力来自于代码训练</strong>是我们倾向于相信的假设 (hypothesis)</li>
<li><strong>对没有见过的任务泛化能力来自大规模指令学习</strong> 是至少 4 篇论文的结论 (conclusion)</li>
<li><strong>GPT-3.5来自于其他大型基础模型，而不是1750亿参数的GPT-3</strong> 是有根据的猜测 (educated guess)。</li>
<li><strong>所有这些能力都已经存在了，通过instruction tuning，无论是有监督学习或强化学习的方式来解锁而不是注入这些能力</strong> 是一个比较强的假设 (strong assumption)。 主要是因为instruction tuning数据量比预训练数据量少了几个数量级。</li>
<li>结论 (conclusion) &#x3D; 许多证据支持这些说法的正确性；假设 (hypothesis) &#x3D; 有正面证据但不够有力；有根据的猜测 (educated guess) &#x3D; 没有确凿的证据，但某些因素会指向这个方向</li>
</ul>
</li>
<li>为什么其他模型（如 OPT 和 BLOOM）没有那么强大？<ul>
<li>OPT大概是因为训练过程太不稳定</li>
<li>BLOOM的情况则未知。如果您有更多意见，请与我联系</li>
</ul>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%BD%AC%E8%BD%BD/" class="category-chain-item">转载</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>【转载】深入理解语言模型的突现能力 &amp; 拆解追溯 GPT-3.5 各项能力的起源</div>
      <div>https://occdn.limour.top/2585.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>Limour</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>February 16, 2023</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - Non-commercial">
                    <i class="iconfont icon-nc"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - Share-alike">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2589.html" title="【AIGC:图】Stable Diffusion 试用【汉服国风】">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">【AIGC:图】Stable Diffusion 试用【汉服国风】</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2582.html" title="Docker：使用 Gost 搭建 HTTPS 代理">
                        <span class="hidden-mobile">Docker：使用 Gost 搭建 HTTPS 代理</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createCssLink('https://cdn.staticfile.org/waline/2.15.5/waline.min.css')
      Fluid.utils.createScript('https://cdn.staticfile.org/waline/2.15.5/waline.min.js', function() {
        var options = Object.assign(
          {"serverURL":"https://comments.limour.top","path":"window.location.pathname","meta":["nick","mail","link"],"requiredMeta":["nick"],"lang":"zh-CN","emoji":["https://jscdn.limour.top/gh/walinejs/emojis/weibo"],"dark":"html[data-user-color-scheme=\"dark\"]","wordLimit":0,"pageSize":10},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        Waline.init(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          var imgSelector = '#waline .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a target="_blank" rel="nofollow noopener" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=43130202000203"><img src="https://img.limour.top/2023/08/27/64eadeb81d6a0.webp" srcset="https://jscdn.limour.top/gh/Limour-dev/Sakurairo_Vision/load_svg/inload.svg" lazyload>湘公网安备 43130202000203号  </a> <a target="_blank" rel="nofollow noopener" href="https://beian.miit.gov.cn/">湘ICP备20008299号 </a> <a target="_blank" rel="nofollow noopener" href="https://icp.gov.moe/?keyword=20210128">萌ICP备20210128号</a> <br> <a href="https://www.foreverblog.cn/" target="_blank"> <img src="https://img.foreverblog.cn/logo_en_default.png" srcset="https://jscdn.limour.top/gh/Limour-dev/Sakurairo_Vision/load_svg/inload.svg" lazyload alt="" style="width:auto;height:24px"> </a> <br> <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/limour-blog/archives-occdn" target="_blank" rel="nofollow noopener"><span>SRC</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://jscdn.limour.top/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://jscdn.limour.top/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://jscdn.limour.top/npm/jquery@3.6.4/dist/jquery.min.js" ></script>
<script  src="https://jscdn.limour.top/npm/bootstrap@4.6.1/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://jscdn.limour.top/npm/tocbot@4.20.1/dist/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://jscdn.limour.top/npm/anchor-js@4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
<!-- hexo injector body_end start -->
  <script defer src="/theme-inject/timeliness.js"></script>
<!-- hexo injector body_end end --></body>
</html>
